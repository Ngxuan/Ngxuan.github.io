<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Library</title>
    {% load static %}
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/super-dessert" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<style>
  body {
    font-family: 'Arial', sans-serif;
    position: relative;
    margin: 0;
    padding: 0;
    height: 100%;
    overflow-x: hidden;
}

/* Page Title Styling */
.library-title {
    font-size: 48px;
    color: #ffd700;
    font-family: 'Super Dessert', sans-serif;
}

/* Back Arrow Styles */
.back-button {
    font-size: 30px;
    color: #000;
    position: absolute;
    top: 20px; /* Adjust position to match design */
    left: 50px; /* Adjust position to match design */
    text-decoration: none;
    z-index: 1000; /* Ensure it stays on top */
    transition: color 0.3s ease;
}

.back-button:hover {
    color: #ffd700; /* Change color on hover */
}

/* Card Styles */
.card {
    width: 360px; /* Adjust the width */
    height: auto; /* Adjust the height */
    border: none;
    transition: transform 0.2s ease;
    margin: 0 20px;
}
.card img {
    width: 100%; /* Set the width to match the card */
    height: 200px; /* Set a fixed height */

}

.cardContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start; /* Align cards to the left */
    align-items: flex-start; /* Align cards to the top */

}

.card:hover {
    transform: scale(1.05);
}

.card-title {
    font-size: 18px;
    text-align: center;
    color: #333;
}

/* Specific CSS styles for achievement cards */
.achievement-card {
    display: flex;
    align-items: center;
    justify-content: start;
    border: 1px solid #ddd;
    border-radius: 8px;
    margin: 20px;
    padding:20px;
    background-color: #ffffff;
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease;
    width: 350px; /* Define a fixed width for consistency */
}

.achievement-container {
    display: flex;
    align-items: center;
    min-height:150px;
}

.achievement-badge {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    margin-right: 15px;
}

.achievement-details {
    display: flex;
    flex-direction: column;
    text-align: left;
}

.achievement-title {
    font-size: 18px;
    font-weight: bold;
    margin: 20 20;
    color: #333;
}

.achievement-description {
    font-size: 14px;
    margin: 5px 0 0;
    color: #666;
}

.completion-percentage{
   margin: 5px 0 0;
}

/* Locked Achievements */
.locked-achievement {
    opacity: 0.2; /* Reduce opacity for locked achievements */
    background: #f0f0f0; /* Light gray background for locked achievements */
}

.locked-achievement .achievement-title,
.locked-achievement .achievement-description {
    color: #999; /* Gray text for locked achievements */
}


/* Bubble Navigation Styles */
.bubble-container {
    text-align: center;
}

.bubble {
    width: 110px;
    height: 110px;
    background-color: rgba(173, 216, 230, 0.5); /* Light blue with some transparency */
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1); /* Bubble shadow effect */
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.bubble::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 15px;
    width: 30px;
    height: 30px;
    background-color: rgba(255, 255, 255, 0.6); /* Light reflection */
    border-radius: 50%;
}

.bubble-label {
    margin-top: 10px;
    font-size: 18px;
    color: grey;
    padding: 5px;
    transition: background-color 0.3s ease, color 0.3s ease;
    font-weight: bold;
    text-align: center;
}

.bubble.active {
    background-color: #ffd700 !important; /* Yellow when clicked */
}

.bubble-label.active {
    background-color: grey; /* Grey background */
    color: white; /* White text */
    border-radius: 5px;
}

.bubble img {
    width: 50px;
    height: 50px;
}

/* Flexbox layout with adjustable gap */
.d-flex {
    gap: 10%; /* Adjust the space between bubbles */
    justify-content: center; /* Center the bubbles horizontally */
}

/* Arrow Button Styles */
.nav-button {
    position: fixed;
    top: 50%;
    background: #17a2b8;
    border: none;
    border-radius: 50%;
    padding: 15px;
    cursor: pointer;
    z-index: 1000;
    transition: background 0.3s, transform 0.3s;
}

.nav-button img {
    width: 40px;
    height: 40px;
}

#prevPageButton {
    left: 20px; /* Fixed on the left side */
}

#nextPageButton {
    right: 20px; /* Fixed on the right side */
}

.nav-button:hover {
    background: #138496;
    transform: scale(1.1);
}

        .home-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #17a2b8;
            border: none;
            border-radius: 50%;
            padding: 10px;
            cursor: pointer;
            z-index: 1000;
            transition: background 0.3s, transform 0.3s;
        }

        .home-button:hover {
            background: #138496;
            transform: scale(1.1);
        }

        .home-button img {
            width: 30px;
            height: 30px;
        }


/* Media queries for smaller screens */
@media (max-width: 768px) {
    .bubble {
        width: 120px; /* Decrease size of bubbles for smaller screens */
        height: 120px;
    }
    .library-title {
        font-size: 36px; /* Make the title smaller on smaller screens */
    }
}

@media (max-width: 576px) {
    .bubble {
        width: 100px; /* Further reduce size for very small screens */
        height: 100px;
    }
    .library-title {
        font-size: 28px; /* Further reduce the title size */
    }
    .d-flex {
        gap: 20px; /* Reduce gap for smaller screens */
    }
}
</style>
<body>
    <div class="container mt-2">
        <!-- Header -->

         <a href="{% url 'choose_profile' %}" class="home-button">
            <button style="background: transparent; border: none;">
                <img src="https://img.icons8.com/material-rounded/24/ffffff/home.png" alt="Home">
            </button>
        </a>
        <div class="text-center">
            <h1 class="library-title">Library</h1>
        </div>

        <!-- Navigation Buttons -->
        <div class="d-flex my-4">
            <!-- Create bubbles with onclick events that call the filterContent function with a category parameter -->
            <div class="bubble-container">
                <div class="bubble active" onclick="toggleActive(this, 'book')"> <!-- Set default active class -->
                    <img src="{% static 'image/book.png' %}" alt="Books">
                </div>
                <div class="bubble-label active">Books</div> <!-- Set default active class -->
            </div>

            <div class="bubble-container">
                <div class="bubble" onclick="toggleActive(this, 'video')">
                    <img src="{% static 'image/video.png' %}" alt="Videos">
                </div>
                <div class="bubble-label">Videos</div>
            </div>

            <div class="bubble-container">
                <div class="bubble" onclick="toggleActive(this, 'quiz')">
                    <img src="{% static 'image/quiz.png' %}" alt="Quizzes">
                </div>
                <div class="bubble-label">Quizzes</div>
            </div>

            <div class="bubble-container">
                <div class="bubble" onclick="toggleActive(this, 'game')">
                    <img src="{% static 'image/game.png' %}" alt="Games">
                </div>
                <div class="bubble-label">Games</div>
            </div>

            <div class="bubble-container">
                <div class="bubble" onclick="toggleActive(this, 'achievement')">
                    <img src="{% static 'image/achievement.png' %}" alt="Achievements">
                </div>
                <div class="bubble-label">Achievements</div>
            </div>
        </div>

        <!-- Video and Image Cards Section -->
        <div class="cardContainer" id="cardContainer" data-child-id="{{ child.childID }}"></div>
    </div>
        <div class="text-center mt-4">
            <h2>Real-time Gesture Detection</h2>
            <img src="{% url 'video_feed' %}" width="640" height="480" alt="Real-time Video Feed">
        </div>
    <!-- Left and Right Arrow Buttons for Pagination -->
    <button id="prevPageButton" class="nav-button">
        <img src="https://img.icons8.com/material-rounded/48/ffffff/left.png" alt="Previous">
    </button>
    <button id="nextPageButton" class="nav-button">
        <img src="https://img.icons8.com/material-rounded/48/ffffff/right.png" alt="Next">
    </button>

    <script>
// Function to toggle active class and filter content
function toggleActive(element, category) {
    var bubbles = document.querySelectorAll('.bubble');
    bubbles.forEach(function(bubble) {
        bubble.classList.remove('active');
        if (bubble.nextElementSibling) {
            bubble.nextElementSibling.classList.remove('active');
        }
    });
    element.classList.add('active');
    if (element.nextElementSibling) {
        element.nextElementSibling.classList.add('active');
    }
    currentPage = 1;  // Reset to first page when a new category is selected
    filterContent(category);
}

// Global variables for pagination
let currentPage = 1;  // Track current page
const itemsPerPage = 6;  // Number of items to show per page

// Function to fetch and filter content based on category and paginate
function filterContent(category) {
    currentCategory = category; // Update current category
    const cardContainer = document.getElementById('cardContainer');
    const childID = cardContainer.getAttribute('data-child-id');
    fetch(`/libraries/library/?category=${category}&childID=${childID}`, {  // Include childID in URL
        headers: { 'X-Requested-With': 'XMLHttpRequest' }
    })
    .then(response => response.json())
    .then(data => {
        const cardContainer = document.getElementById('cardContainer');
        cardContainer.innerHTML = '';  // Clear the current content

        const childID = cardContainer.getAttribute('data-child-id');

        if (!data.content || data.content.length === 0) {
            console.log("No content found for this category.");
            return;
        }

        const totalItems = data.content.length;
        const totalPages = Math.ceil(totalItems / itemsPerPage);

        if (currentPage > totalPages) {
            currentPage = totalPages;
        } else if (currentPage < 1) {
            currentPage = 1;
        }

        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;
        const paginatedContent = data.content.slice(startIndex, endIndex);

        paginatedContent.forEach(item => {
            const col = document.createElement('div');
            col.classList.add('col-md-4', 'mb-1');

            const card = document.createElement('div');
            // Apply the 'achievement-card' class only for achievement category
        if (category === 'achievement') {
            card.classList.add('achievement-card');

            // Create the achievement card structure
            const achievementContainer = document.createElement('div');
            achievementContainer.classList.add('achievement-container');

            const badgeImage = document.createElement('img');
            badgeImage.src = item.thumbnail_url || 'https://via.placeholder.com/100x100';
            badgeImage.classList.add('achievement-badge');

            // Conditionally add locked-achievement class to the badge image
            if (!item.completed) {
                badgeImage.classList.add('locked-achievement');
            }

            const detailsContainer = document.createElement('div');
            detailsContainer.classList.add('achievement-details');

            const cardTitle = document.createElement('h5');
            cardTitle.classList.add('achievement-title');
            cardTitle.innerText = item.title;

            const description = document.createElement('p');
            description.classList.add('achievement-description');
            description.innerText = item.description || 'No Description Available';

            // Display completion percentage if available
            // Display completion if available
            const completionPercentage = document.createElement('p');
            completionPercentage.classList.add('completion-percentage');

            // Assuming `item.currentValue` holds the current progress and `item.targetValue` holds the total criteria
            if (item.completionMetric === 'time_spent' && item.formattedCriteria) {
                // Display formatted criteria in hours and minutes
                completionPercentage.innerText = `${item.currentValue} / ${item.formattedCriteria}`;
            } else {
                // Display as-is for other metrics
                completionPercentage.innerText = `${item.currentValue} / ${item.targetValue}`;
            }


            detailsContainer.appendChild(cardTitle);
            detailsContainer.appendChild(description);
            detailsContainer.appendChild(completionPercentage); // Append completion percentage here
            achievementContainer.appendChild(badgeImage);
            achievementContainer.appendChild(detailsContainer);
            card.appendChild(achievementContainer);
             } else {
                // For other categories, use the standard card structure
                card.classList.add('card');

                const link = document.createElement('a');
                link.href = '#';
                link.style.cursor = 'pointer';
                link.addEventListener('click', () => {
                    if (category === 'book') {
                        openBookViewer(item.file_url, childID, item.eduMaterialID);
                    } else if (category === 'video') {
                        playVideoInFullScreen(item.file_url, childID, item.eduMaterialID);
                    } else if (category === 'quiz') {
                        openQuizPage(childID, item.quizID);
                    } else if (category === 'game') {
                        openGamePage(childID, item.gameID);
                    }
                });

                const thumbnailUrl = item.thumbnail_url || 'https://via.placeholder.com/350x200';
                const img = document.createElement('img');
                img.src = thumbnailUrl;
                img.classList.add('card-img-top');
                img.alt = item.title;

                link.appendChild(img);
                card.appendChild(link);

                const cardBody = document.createElement('div');
                cardBody.classList.add('card-body');

                const cardTitle = document.createElement('h5');
                cardTitle.classList.add('card-title');
                cardTitle.innerText = item.title || 'No Title Available';

                cardBody.appendChild(cardTitle);
                card.appendChild(cardBody);
            }

            col.appendChild(card);
            cardContainer.appendChild(col);
        });

        updatePaginationControls(totalPages);
    })
    .catch(error => {
        console.error("Error fetching data:", error);
    });
}


// Show and update pagination controls based on the total pages
function updatePaginationControls(totalPages) {
    const prevButton = document.getElementById('prevPageButton');
    const nextButton = document.getElementById('nextPageButton');

    // Show or hide buttons based on total pages
    if (totalPages <= 1) {
        // If only one page or no content, hide both buttons
        prevButton.style.display = 'none';
        nextButton.style.display = 'none';
    } else {
        // Show buttons if more than one page
        prevButton.style.display = 'block';
        nextButton.style.display = 'block';

        // Enable/disable buttons based on current page
        prevButton.disabled = currentPage === 1;
        nextButton.disabled = currentPage === totalPages;

        // If on the first page, hide the previous button
        if (currentPage === 1) {
            prevButton.style.display = 'none';
        } else {
            prevButton.style.display = 'block';
        }

        // If on the last page, hide the next button
        if (currentPage === totalPages) {
            nextButton.style.display = 'none';
        } else {
            nextButton.style.display = 'block';
        }
    }
}


// Function to handle Previous button click
function handlePreviousPageClick() {
    if (currentPage > 1) {
        currentPage--;
        filterContent(currentCategory); // Use the current category
    }
}

// Function to handle Next button click
function handleNextPageClick() {
    const childID = cardContainer.getAttribute('data-child-id');

    // Fetch data again to determine the total items for pagination
    fetch(`/libraries/library/?category=${currentCategory}&childID=${childID}`, {
        headers: { 'X-Requested-With': 'XMLHttpRequest' }
    })
    .then(response => response.json())
    .then(data => {
        const totalItems = data.content.length;
        const totalPages = Math.ceil(totalItems / itemsPerPage);

        if (currentPage < totalPages) {
            currentPage++;
            filterContent(currentCategory); // Use the current category
        }
    })
    .catch(error => {
        console.error("Error handling Next button click:", error);
    });
}


// Function to open the book viewer in a new page
function openBookViewer(bookUrl, childID, eduMaterialID) {
    window.location.href = `/eduMaterial/book/${childID}/${eduMaterialID}/?bookUrl=${encodeURIComponent(bookUrl)}`;
}
function openQuizPage(childID, quizID) {
    window.location.href = `/quizzes/quiz/${childID}/${quizID}/`;
}
function openGamePage(childID, gameID) {
    // Construct the URL to the game page with the necessary parameters in the correct order
    const gamePageUrl = `/games/play/${childID}/${gameID}`;

    // Redirect or open the game page
    window.location.href = gamePageUrl;
}
// Function to play video in full screen (for videos)

// Function to play video in full screen (for videos)
function playVideoInFullScreen(videoUrl, childID, eduMaterialID) {  // Include childID and eduMaterialID as parameters
    const videoElement = document.createElement('video');
    videoElement.src = videoUrl;
    videoElement.controls = true;
    videoElement.style.display = 'none';

    document.body.appendChild(videoElement);

    // Variables to track time spent
    let startTime = 0;
    let accumulatedTime = 0;
    let interval;

    // Event listener to start tracking when the video starts playing
    videoElement.addEventListener('play', () => {
        startTime = Date.now();  // Record the start time
        interval = setInterval(updateTimeSpent, 1000); // Update time every second
    });

    // Event listener to stop tracking when the video is paused
    videoElement.addEventListener('pause', () => {
        if (startTime) {
            accumulatedTime += Date.now() - startTime; // Add the difference to accumulatedTime
            startTime = 0;  // Reset start time
            clearInterval(interval);  // Stop updating the time
        }
    });

    // Event listener to stop tracking when the video ends
    videoElement.addEventListener('ended', () => {
        if (startTime) {
            accumulatedTime += Date.now() - startTime;  // Add the remaining time when video ends
            clearInterval(interval);  // Stop updating the time
            sendTimeSpent(childID, eduMaterialID, accumulatedTime / 1000);  // Convert milliseconds to seconds and send
            startTime = 0;
        }
        removeVideoElement(videoElement);  // Remove the video element from the DOM
    });

    // Event listener to handle when the video enters full screen and starts playing
    videoElement.addEventListener('loadedmetadata', () => {
        videoElement.style.display = 'block';
        videoElement.play();  // Play the video automatically

        // Request full screen depending on the browser support
        if (videoElement.requestFullscreen) {
            videoElement.requestFullscreen();
        } else if (videoElement.mozRequestFullScreen) {
            videoElement.mozRequestFullScreen();
        } else if (videoElement.webkitRequestFullscreen) {
            videoElement.webkitRequestFullscreen();
        } else if (videoElement.msRequestFullscreen) {
            videoElement.msRequestFullscreen();
        }
    });

    // Add event listeners to track when exiting full screen
    document.addEventListener('fullscreenchange', () => handleExitFullscreen(childID, eduMaterialID));
    document.addEventListener('webkitfullscreenchange', () => handleExitFullscreen(childID, eduMaterialID));
    document.addEventListener('mozfullscreenchange', () => handleExitFullscreen(childID, eduMaterialID));
    document.addEventListener('MSFullscreenChange', () => handleExitFullscreen(childID, eduMaterialID));

    // Function to remove the video element from the DOM
    function removeVideoElement(videoElement) {
        if (document.body.contains(videoElement)) {
            document.body.removeChild(videoElement);
        }
    }

    // Function to handle exiting full screen and recording time spent
    function handleExitFullscreen(childID, eduMaterialID) {
        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
            if (startTime) {
                accumulatedTime += Date.now() - startTime;  // Add remaining time when exiting full screen
                clearInterval(interval);  // Stop updating the time
                sendTimeSpent(childID, eduMaterialID, accumulatedTime / 1000);  // Convert milliseconds to seconds and send
                startTime = 0;
            }
            removeVideoElement(videoElement);  // Remove the video element from the DOM
        }
    }

    // Function to send time spent on the video to the server
    function sendTimeSpent(childID, eduMaterialID, timeSpentInSeconds) {
        if (!eduMaterialID) {
            console.error("eduMaterialID is missing or incorrect.");
            return;
        }

        console.log(`Child ID: ${childID}, EduMaterial ID: ${eduMaterialID}`); // Log IDs to check for correctness

        // Send the time spent to the server using AJAX
        fetch(`/eduMaterial/record_time_spent/${childID}/${eduMaterialID}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken(),  // Add CSRF token if required
            },
            body: JSON.stringify({
                timeSpent: timeSpentInSeconds
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                console.log('Time spent recorded successfully.');
            } else {
                console.error('Failed to record time spent:', data.message);
            }
        })
        .catch(error => {
            console.error('Error recording time spent:', error);
        });
    }

    // Function to get CSRF token from cookie (if needed)
    function getCSRFToken() {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, 'csrftoken'.length + 1) === 'csrftoken=') {
                    cookieValue = decodeURIComponent(cookie.substring('csrftoken'.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Function to continuously update the accumulated time
    function updateTimeSpent() {
        if (startTime) {
            const currentTime = Date.now();
            const timeSpentInMilliseconds = currentTime - startTime;  // Calculate time spent since the last update
            accumulatedTime += timeSpentInMilliseconds;  // Add to accumulated time
            startTime = currentTime;  // Reset start time for the next calculation
            console.log(`Time spent so far: ${accumulatedTime / 1000} seconds`);  // Log for debugging
        }
    }
}

// Set default active category and pagination on page load
window.onload = function() {
    const defaultBubble = document.querySelector('.bubble.active');
    if (defaultBubble) {
        currentPage = 1;  // Reset to page 1 on new category selection
        toggleActive(defaultBubble, 'book');
    }

    // Attach click event listeners to pagination buttons
    document.getElementById('prevPageButton').addEventListener('click', handlePreviousPageClick);
    document.getElementById('nextPageButton').addEventListener('click', handleNextPageClick);
};

    </script>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>